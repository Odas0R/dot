# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

#
# Table
#

snippet /* "comment block" b
/*
 * $0
 */
endsnippet

snippet table "Create a sql table"
create table if not exists public.${1:table} (
	$2 ${3:uuid} not null ${4:default extensions.uuid_generate_v4 ()}
	${0}
	, created_at timestamp with time zone default
		timezone('utc'::text , now())

	-- constraints (keys)
	, constraint $1_pkey primary key ($2)

	-- constraints (checks)
);
endsnippet

#
# Keys Contraints
#

snippet ct "postgresql constraint" b
/*
 * Add constraint "${1:${VISUAL:ct}}" on ${2:${VISUAL:public.table}}
 */
alter table $2
	drop constraint if exists $1;

alter table $2
	add constraint $1 ${3:${VISUAL:check(char_length(col) = 2)}} not valid;

alter table $2 validate constraint $1;
endsnippet

snippet foreignkey "postgresql constraint foreign key" b
/*
 * Add foreign key constraint ${1:${VISUAL:fkey}} to table 
 *Â ${2:${VISUAL:table_referencing}} (${3:${VISUAL:fkey_ref}}) referencing ${4:${VISUAL:table_to_reference}}
 */
alter table $2
	drop constraint if exists $1;

alter table $2
	add constraint $1 foreign key ($3) references $4
		on delete cascade not valid;

alter table $2 validate constraint $1;
endsnippet

#
# Row Level Security
#

snippet rls "Add row level security for a schema" b
alter table if exists $1 enable row level security;
endsnippet

snippet rls:select "Add a postgres row level security policy on select for a schema" b
create policy select_policy on public.$1
	for select
		using (${0:auth.uid () = user_id});
endsnippet

snippet rls:insert "Add a postgres row level security policy on insert for a schema" b
create policy insert_policy on public.$1
	for insert
		with check (${0:auth.uid () = user_id});
endsnippet

snippet rls:update "Add a postgres row level security policy on update for a schema" b
create policy update_policy on public.$1
	for update
		using (${0:auth.uid () = user_id});
endsnippet

snippet rls:delete "Add a postgres row level security policy on delete for a schema" b
create policy delete_policy on public.$1
	for delete
		using (${0:auth.uid () = user_id});
endsnippet

#
# Triggers
#

snippet trigger "Create a trigger" b
create or replace function public.$1 ()
returns trigger as
language plpgsql
security definer
set search_path = public
$$
begin
	$0
	return new;
end;
$$;

create trigger $1
	${2:before} ${3:insert or update} on public.${4:table} for each row
	execute procedure public.$1 ();
endsnippet

#
# PGTap
#

snippet pgtap "Unit test" b
\echo ===================================================
\echo Testing: $1
\echo ===================================================

begin;

select no_plan();

set local search_path = public, auth, extensions;
set local role anon;

	select
		is_empty(
			$$
			select * from public.$1;
			$$,
			'anon cannot see any $1'
		);

-- set local "request.jwt.claim.sub" to :'user_0';


select * from finish();

do $$ begin assert num_failed() = 0; end $$;

rollback;
endsnippet

#
# pgTap common functions
#

snippet results_eq "pgtap results_eq unit test function" b
select 
  results_eq(
    $$
    ${2:${VISUAL:select (1)}}
    $$,
    $$
    ${3:${VISUAL:values (1)}}
    $$,
    '$1'
  );
endsnippet

snippet set_eq "pgtap set_eq unit test function" b
select 
  set_eq(
    $$
    ${2:${VISUAL:select (1)}}
    $$,
    $$
    ${3:${VISUAL:values (1)}}
    $$,
    '$1'
  );
endsnippet

snippet is_empty "pgtap is_empty unit test function" b
select 
  is_empty(
    $$
    ${2:${VISUAL:select (1)}}
    $$,
    '$1'
  );
endsnippet

snippet lives_ok "pgtap lives_ok unit test function" b
select 
  lives_ok(
    $$
    ${2:${VISUAL:select (1)}}
    $$,
    '$1'
  );
endsnippet

snippet throws_ok "pgtap throws_ok unit test function" b
select 
  throws_ok(
    $$
    ${2:${VISUAL:select (1)}}
    $$,
    ${3:${VISUAL:111}},
    '${4:${VISUAL:some postgres error message thrown}}',
    '$1'
  );
endsnippet

#
# Common
#
snippet if "if-else statement" b
if ${1:${VISUAL:condition}} then
	$0
end if;
endsnippet
