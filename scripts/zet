#!/usr/bin/env bash

set -e

# Opens the current routine. Your zet workflow:
#
# format: this-is-a-note.isotime.md
#
# [ ] Linking:          Link two zets w/ the $isotime (copy it w/ tmux selection)
# [ ] Progress:         Tells you how much time you've worked in the past
#                       week, month, year. Metrics for pomodoro
# [ ] Orphans:          Finds all the notes that are orphans, notes that are
#                       orphans don't contain "# Links" at the bottom of the file

ZET="${HOME}/zet"
INBOX="${ZET}/inbox"
BOOKS="${ZET}/books"
ROUTINES="${ZET}/routines"

print_help() {
  printf "
Zettelkasten program
It is organized by inbox & permanent notes.

Commands:
  --help | -h           Show help commands
  q  | query            Queries the zettels with Regex, you can filter by tags.
  l  | link 						Links two zettels
  nb | new-book         Creates a new file for book anotations.
  r  | routine          Opens the current routine.
  fr | find-routine     Opens a panel w/ preview to fuzzy-find a routine

"
}

# Creates a new file on the /inbox w/ a template.
zet_new() {
  fileName=$(echo "$@" | sed "s/[?|!]//g" | sed "s/ /-/g" | tr "[:upper:]" "[:lower:]")
  file="${INBOX}/${fileName}.$(isosec).md"

  tee "$file" <<EOF >/dev/null
# $@

# Bibliography
EOF

  vim +2 "$file"
}

# Creates a new file on the /books w/ a template.
zet_newbook() {
  fileName=$(echo "$@" | sed "s/[?|!]//g" | sed "s/ /-/g" | tr "[:upper:]" "[:lower:]")
  file="${BOOKS}/${fileName}.md"

  # Create the note with the $fileName
  tee "$file" <<EOF >/dev/null
# $@

EOF

  vim +2 "$file"
}

# Creates a new file on the /books w/ a template.
zet_newroutine() {
  fileName=$(echo "$@" | sed "s/[?|!]//g" | sed "s/ /-/g" | tr "[:upper:]" "[:lower:]")
  file="${ROUTINES}/${fileName}.$(isosec).md"

  # if there's no args opens the last routine
  if [[ -z "$fileName" ]]; then
    cd "$ROUTINES"
    lastFile="$(ls -lat | head -2 | tail -1 | awk '{print $9}')"
    echo "$lastFile"
    vim "$lastFile"
  else
    # Creates a new routine
    touch "$file"
    vim "$file"
  fi
}

zet_find_routine() {
  # Opens a fzf panel with preview
  cd "$ROUTINES"
  file="$(fzf --preview 'bat --style=numbers --color=always {}')"
  [[ -f "$file" ]] && vim "$file"
}

zet_query() {
  # -m NUM	: Stops reading a file after NUM matching lines
  # w				: exact matches in a file
  # Ctrl+f	: change to fzf for more precise findings

  # example: https://github.com/junegunn/fzf/blob/master/ADVANCED.md#using-fzf-as-interative-ripgrep-launcher
  cd "$INBOX"
  RG_PREFIX="rg --column --line-number --no-heading --color=always --ignore-case -m 3 -w "
  INITIAL_QUERY="${*:-}"
  IFS=: read -ra selected < <(
    FZF_DEFAULT_COMMAND="$RG_PREFIX $(printf %q "$INITIAL_QUERY")" \
      fzf --ansi \
      --disabled --query "$INITIAL_QUERY" \
      --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \
      --bind "ctrl-f:unbind(change,ctrl-f)+change-prompt(2. fzf> )+enable-search+clear-query" \
      --prompt '1. ripgrep> ' \
      --delimiter : \
      --preview 'bat --theme="OneHalfDark" --color=always {1} --highlight-line {2}'
  )
  [ -n "${selected[0]}" ] && vim "${selected[0]}" "+${selected[1]}"
}

zet_link() {
  # If no args open two fzf panels to select the files, and append the file1
  # url into the file2
  cd "$INBOX"
  file1="$(fzf --preview 'bat --style=numbers --color=always {}')"
  [[ -z "$file1" ]] && exit 1
  file2="$(fzf --preview 'bat --style=numbers --color=always {}')"
  [[ -z "$file2" ]] && exit 1

  echo "$file1"
  echo "$file2"

  # if there's args, they must be a valid zet id

}

#
# Zet Commands
#
case $1 in
-h | --help)
  print_help
  exit 0
  ;;
"")
  print_help
  exit 0
  ;;
q | query)
  zet_query "${@:2}"
  exit 0
  ;;
l | link)
  zet_link "${@:2}"
  exit 0
  ;;
nb | new-book)
  zet_newbook "${@:2}"
  exit 0
  ;;
r | routine)
  zet_newroutine "${@:2}"
  exit 0
  ;;
fr | find-routine)
  zet_find_routine
  exit 0
  ;;
esac

# Checks if the first given argument is a valid id.
# If it is a zet file, it will open it, otherwise creates a new file
firstArg="$(find "$INBOX" -name "*.${1}.md")"
if [ -n "$firstArg" ]; then
  vim "$firstArg"
else
  zet_new "$@"
fi
