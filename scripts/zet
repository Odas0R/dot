#!/usr/bin/env bash

set -e

ZET=${HOME}/zet
INBOX=${ZET}/inbox
PROJECTS=${ZET}/projects

print_help() {
  printf "
A personal zettelkasten program

Commands:
  help             Show help commands
  new              Create a new zettel by giving it a title
  query            Queries the zettels with Regex, you can filter by tags
  orpahns          Query ophan notes
  link             Links two zettels
  new-book         Creates a new file for book anotations
  books            Finds all books with fzf
  proj             Finds, and create projects automatically for you
  rename           Renames the current zet from the '# title'

"
}

# Creates a new note with the given file and title
new_note() {
  file="$1"
  title="$2"

  if [[ -z "$file" ]] || [[ -z "$title" ]]; then
    echo "failed to create a note: invalid arguments"
    exit 1
  fi

  tee "$file" <<EOF >/dev/null
# $title


EOF
  nvim +3 "$file"
}

query_fzf() {
  file=$(fd -e md | fzf --preview 'bat --theme='gruvbox-dark' --color=always {}')
  [[ -n "$file" ]] && nvim "$file"
}

# Querying workflow:
#
# 1. Query for specific words to get all files that contain that word
# 2. Fuzzy find till you get what you want
#
# https://github.com/junegunn/fzf/blob/master/ADVANCED.md#using-fzf-as-interative-ripgrep-launcher
# TODO: Remove the ```$query from the fzf search (ANNOYING ASF)
query() {
  INITIAL_QUERY="${*:-}"

  if [[ -z $INITIAL_QUERY ]]; then
    echo "the query can't be empty"
    exit 1
  fi

  # remove all the codeblocks -- bad for querying
  #
  # 1. remove codeblocks from all the files and put them into a
  # /tmp/zet_query directory
  # 2. query that directory
  # 3. open the file on the previous directory
  dir="/tmp/.zet_query"
  [[ -d "$dir" ]] && rm -rf "$dir"

  # clean up query files
  mkdir -p "$dir"

  # copy all files to the temporary directory
  rg -li "$INITIAL_QUERY" | xargs -I{} cp {} "$dir"

  cd "$dir"

  # remove codeblocks
  rg -li "$INITIAL_QUERY" | xargs -I{} sed -i -e '/^```/,/^```/d' {}

  # clean up backup files
  rm ./*.md-e

  # query
  FIRST_SEARCH="rg --column --line-number --no-heading --color=always --ignore-case "
  IFS=: read -ra selected < <(
    eval "$FIRST_SEARCH $(printf %q "$INITIAL_QUERY")" |
      fzf --ansi \
        --multi \
        --query "" \
        --delimiter : \
        --preview 'bat --theme='gruvbox-dark' --color=always {1} --highlight-line {2}'
  )
  [ -n "${selected[0]}" ] && nvim "${INBOX}/${selected[0]}" "+${selected[1]}"
}

# Creates a new file on the inbox/ with a default template
#
# It parses the given title so that it generates a nice filename for
# easier access when querying.
zet_new() {
  fileName=$(echo "$@" | sed "s/[^a-zA-Z0-9]/ /g" | sed "s/[ ][ ]*/ /g" | sed "s/ /-/g" | tr "[:upper:]" "[:lower:]")
  file="${INBOX}/${fileName}.$(isosec).md"
  title="${*}"

  new_note "$file" "$title"
}

# Queries all the files under the inbox/
zet_query() {
  cd "$INBOX"
  query "$*"
}

# Queries all the files under the inbox/ that doesn't contain links
zet_orphans() {
  cd "$INBOX"

  # copy all orphans into .orphans
  mkdir -p .orphans
  grep -iHnL "# Links" ./*.md* | cut -d: -f-1 | xargs -I{} cp {} .orphans

  # go to the folder where the orphans are
  cd .orphans

  query "$*"

  # clean-up
  cd - >/dev/null
  rm -rf .orphans
}

# Renames a given file with the title that is written on the first line
# of the file.
zet_rename() {
  if [[ ! -f "$1" ]]; then
    echo "The given file was not valid."
    exit 1
  fi

  title=$(
    head -n 1 "$1" |
      sed "s/# //" |
      sed "s/[^a-zA-Z0-9]/ /g" |
      sed "s/[ ][ ]*/ /g" |
      sed "s/ /-/g" |
      tr "[:upper:]" "[:lower:]"
  )
  fileID="$(echo "$1" | cut -d '.' -f 2)"
  file=""

  if [[ $fileID == "md" ]]; then
    file="${title}.md"
  else
    file="${title}.${fileID}.md"
  fi

  # create the new file, and delete the old one
  oldFilePath=$(realpath "$(dirname "$1")")/$(basename "$1")
  newFilePath=$(realpath "$(dirname "$1")")/${file}

  cat "$oldFilePath" >"$newFilePath"
  # echo "$oldFilePath"
  rm "$oldFilePath"

  # echo "Note renamed to $newFilePath"
}

# TODO: Don't show the files on fzf that are already linked to the first
# chosen file
zet_link() {
  # If no args open two fzf panels to select the files, and append the file1
  # url into the file2
  cd "$INBOX"

  fileOne="$(fzf --preview 'bat --theme='gruvbox-dark'   --color=always {}')"
  fileTwo="$(fzf --preview 'bat --theme='gruvbox-dark'   --color=always {}')"

  if [[ "$fileOne" == "$fileTwo" ]]; then
    echo "You can't link the same file." >&2
    exit 1
  fi

  fileTwoTitle="$(head -n 1 "$fileTwo")"
  fileTwoLink="* [${fileTwoTitle### }](./${fileTwo})"

  # Add '# Links' to the bottom of the note if it doesn't exist
  if [[ -z "$(grep -n "# Links" "$fileOne")" ]]; then
    if [[ -z "$(tail -1 "$fileOne")" ]]; then
      printf "# Links\n\n" >>"$fileOne"
    else
      printf "\n# Links\n\n" >>"$fileOne"
    fi
  fi

  # add a \n if '# Links' is in the last line
  if [[ "$(tail -1 "$fileOne")" == "# Links" ]]; then
    echo >>"$fileOne"
  fi

  # Add the links on each file
  echo "$fileTwoLink" >>"$fileOne"
}

zet_project() {
  cd "$PROJECTS"

  # if no args query all projects
  if [[ -z "$1" ]]; then
    echo "cannot recieve empty arguments"
    exit 1
  fi

  project="$1"
  title="$2"

  # if there's no project and there's no title , create project
  if [[ ! -d "$project" ]] && [[ -z "$title" ]]; then
    read -r -p "${project} doesn't exists, want to create it?" yes
    case "$yes" in
    y | yes | ok | okay) exec mkdir "$project" ;;
    *) exit 0 ;;
    esac
    echo "$project created"
    exit 0
  fi

  # if project exists and there's no title , open fzf on that folder
  if [[ -d "$project" ]] && [[ -z "$title" ]]; then
    echo "note title cannot be empty"
    exit 1
  fi

  # if there's no project and there's title args, create project and
  # note
  if [[ ! -d "$project" ]] && [[ -n "$args" ]]; then
    read -r -p "project /$1 doesn't exist, should I create it? [y/Y]" yes
    case "$yes" in
    y | yes | ok | okay) mkdir "$project" ;;
    *) exit 0 ;;
    esac
  fi

  # if project exists and there's args create a new note
  fileName=$(echo "${@:2}" | sed "s/[^a-zA-Z0-9]/ /g" | sed "s/[ ][ ]*/ /g" | sed "s/ /-/g" | tr "[:upper:]" "[:lower:]")
  file="${project}/${fileName}.$(isosec).md"
  title="${*:2}"

  new_note "$file" "$title"
}

zet_query_project() {
  local project="$HOME/zet/projects/$1"

  # if project does not exist exit
  if [[ ! -d "$project" ]]; then
    echo "project does not exist"
    exit 1
  fi

  # query the project
  cd "$project"
  query_fzf
  # query "${*:2}"
}

case "$1" in
help)
  print_help
  exit 0
  ;;
"")
  print_help
  exit 0
  ;;
n | new)
  zet_new "${@:2}"
  exit 0
  ;;
q | query)
  zet_query "${@:2}"
  exit 0
  ;;
qp | query-project)
  zet_query_project "${@:2}"
  exit 0
  ;;
link)
  zet_link "${@:2}"
  exit 0
  ;;
orphans)
  zet_orphans "${@:2}"
  exit 0
  ;;
p | project)
  zet_project "${@:2}"
  exit 0
  ;;
rename)
  zet_rename "${@:2}"
  exit 0
  ;;
esac

# Checks if the first given argument is a valid id.
# If it is a zet file, it will open it, otherwise creates a new file
firstArg="$(find "$INBOX" -name "*.${1}.md")"
if [ -n "$firstArg" ]; then
  nvim "$firstArg"
fi
