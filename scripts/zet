#!/usr/bin/env bash

set -e

# Opens the current routine. Your zet workflow:
#
# format: this-is-a-note.isotime.md
#
# [ ] Linking:          Link two zets w/ the $isotime (copy it w/ tmux selection)
# [ ] Progress:         Tells you how much time you've worked in the past
#                       week, month, year. Metrics for pomodoro
# [ ] Orphans:          Finds all the notes that are orphans, notes that are
#                       orphans don't contain "# Links" at the bottom of the file

ZET="${HOME}/zet"
INBOX="${ZET}/inbox"
BOOKS="${ZET}/books"
ROUTINES="${ZET}/routines"

print_help() {
  printf "
Zettelkasten program
It is organized by inbox & permanent notes.

Commands:
  --help | -h           Show help commands
  q  | query            Queries the zettels with Regex, you can filter by tags
  o  | orpahns          Query ophan notes
  l  | link             Links two zettels
  nb | new-book         Creates a new file for book anotations
  r  | rename           Renames the current zet from the '# title'
  ro | routine          Opens the current routine
  fr | find-routine     Opens a panel w/ preview to fuzzy-find a routine

"
}

# Creates a new file on the /inbox w/ a template.
zet_new() {
  fileName=$(echo "$@" | sed "s/[?|!]//g" | sed "s/ /-/g" | tr "[:upper:]" "[:lower:]")
  file="${INBOX}/${fileName}.$(isosec).md"

  tee "$file" <<EOF >/dev/null
# $@


EOF
  nvim +3 "$file"
}

# Creates a new file on the /books w/ a template.
zet_newbook() {
  fileName=$(echo "$@" | sed "s/[?|!]//g" | sed "s/ /-/g" | tr "[:upper:]" "[:lower:]")
  file="${BOOKS}/${fileName}.md"

  tee "$file" <<EOF >/dev/null
# $@


EOF
  nvim +3 "$file"
}

# Creates a new file on the /books w/ a template.
zet_newroutine() {
  fileName=$(echo "$@" | sed "s/[?|!]//g" | sed "s/ /-/g" | tr "[:upper:]" "[:lower:]")
  file="${ROUTINES}/${fileName}.$(isosec).md"

  # if there's no args opens the last routine
  if [[ -z "$fileName" ]]; then
    cd "$ROUTINES"
    lastFile="$(ls -lat | head -4 | tail -1 | awk '{print $9}')"
    nvim "$lastFile"
  else

    # Creates a new routine
    touch "$file"
    nvim "$file"
  fi
}

zet_find_routine() {
  # Opens a fzf panel with preview
  cd "$ROUTINES"
  file="$(fzf --preview 'bat --theme='gruvbox-dark'   --color=always {}')"
  [[ -f "$file" ]] && nvim "$file"
}

zet_query() {
  # -m NUM	: Stops reading a file after NUM matching lines
  # w				: exact matches in a file
  # Ctrl+f	: change to fzf for more precise findings

  # example: https://github.com/junegunn/fzf/blob/master/ADVANCED.md#using-fzf-as-interative-ripgrep-launcher
  cd "$INBOX"
  RG_PREFIX="rg --column --line-number --no-heading --color=always --ignore-case -m 3 -w "
  INITIAL_QUERY="${*:-}"
  IFS=: read -ra selected < <(
    FZF_DEFAULT_COMMAND="$RG_PREFIX $(printf %q "$INITIAL_QUERY")" \
      fzf --ansi \
      --disabled --query "$INITIAL_QUERY" \
      --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \
      --bind "ctrl-f:unbind(change,ctrl-f)+change-prompt(2. fzf> )+enable-search+clear-query" \
      --prompt '1. ripgrep> ' \
      --delimiter : \
      --preview 'bat --theme='gruvbox-dark'   --color=always {1} --highlight-line {2}'
  )
  [ -n "${selected[0]}" ] && nvim "${selected[0]}" "+${selected[1]}"
}

zet_orphans() {
  cd "$INBOX"

  # copy all orphans into .orphans
  mkdir -p .orphans
  grep -iHnL "# Links" ./*.md* | cut -d: -f-1 | xargs -I{} cp {} .orphans
  cd .orphans

  RG_PREFIX="rg --column --line-number --no-heading --color=always --ignore-case -m 3 -w "
  INITIAL_QUERY="${*:-}"
  IFS=: read -ra selected < <(
    FZF_DEFAULT_COMMAND="$RG_PREFIX $(printf %q "$INITIAL_QUERY")" \
      fzf --ansi \
      --disabled --query "$INITIAL_QUERY" \
      --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \
      --bind "ctrl-f:unbind(change,ctrl-f)+change-prompt(2. fzf> )+enable-search+clear-query" \
      --prompt '1. ripgrep> ' \
      --delimiter : \
      --preview 'bat --theme='gruvbox-dark'   --color=always {1} --highlight-line {2}'
  )

  # go back
  cd - >/dev/null

  # open the file on the highlighted line
  [[ -n "${selected[0]}" ]] && nvim "${selected[0]}" "+${selected[1]}"

  # clean-up
  rm -rf .orphans
}

zet_rename() {
  if [[ ! -f "$1" ]]; then
    echo "The given file was not valid."
    exit 1
  fi

  title="$(
    head -n 1 "$1" |
      sed 's/# //g' |
      sed "s/[?|!|,]//g" |
      sed "s/ /-/g" |
      tr "[:upper:]" "[:lower:])"
  )"
  fileID="$(echo "$1" | cut -d '.' -f 2)"

  file="${title}.${fileID}.md"

  # create the new file, and delete the old one
  oldFilePath="$(realpath "$(dirname "$1")")/$(basename "$1")"
  newFilePath="$(realpath "$(dirname "$1")")/${file}"

  cat "$oldFilePath" >"$newFilePath"
  rm "$oldFilePath"

  echo "Note renamed to $newFilePath"
}

zet_link() {
  # if there's args,

  # If no args open two fzf panels to select the files, and append the file1
  # url into the file2
  cd "$INBOX"

  fileOne="$(fzf --preview 'bat --theme='gruvbox-dark'   --color=always {}')"
  fileTwo="$(fzf --preview 'bat --theme='gruvbox-dark'   --color=always {}')"

  if [[ "$fileOne" == "$fileTwo" ]]; then
    echo "You can't link the same file." >&2
    exit 1
  fi

  fileOneTitle="$(head -n 1 "$fileOne")"
  fileTwoTitle="$(head -n 1 "$fileTwo")"

  fileOneLink="* [${fileOneTitle### }](./${fileOne})"
  fileTwoLink="* [${fileTwoTitle### }](./${fileTwo})"

  # Add '# Links' to each file to the bottom of the note if it doesn't
  # exist
  if [[ -z "$(grep -n "# Links" "$fileOne")" ]]; then
    if [[ -z "$(tail -1 "$fileOne")" ]]; then
      printf "# Links\n\n" >>"$fileOne"
    else
      printf "\n# Links\n\n" >>"$fileOne"
    fi
  fi
  if [[ -z "$(grep -n "# Links" "$fileTwo")" ]]; then
    if [[ -z "$(tail -1 "$fileTwo")" ]]; then
      printf "# Links\n\n" >>"$fileTwo"
    else
      printf "\n# Links\n\n" >>"$fileTwo"
    fi
  fi

  # add a \n to both files if '# Links' is in the last line
  if [[ "$(tail -1 "$fileOne")" == "# Links" ]]; then
    echo >>"$fileOne"
  fi
  if [[ "$(tail -1 "$fileTwo")" == "# Links" ]]; then
    echo >>"$fileTwo" # add a \n
  fi

  # Add the links on each file
  echo "$fileTwoLink" >>"$fileOne"
  echo "$fileOneLink" >>"$fileTwo"
}

#
# Zet Commands
#
case $1 in
-h | --help)
  print_help
  exit 0
  ;;
"")
  print_help
  exit 0
  ;;
q | query)
  zet_query "${@:2}"
  exit 0
  ;;
l | link)
  zet_link "${@:2}"
  exit 0
  ;;
o | orphans)
  zet_orphans "${@:2}"
  exit 0
  ;;
nb | new-book)
  zet_newbook "${@:2}"
  exit 0
  ;;
r | rename)
  zet_rename "${@:2}"
  exit 0
  ;;
ro | routine)
  zet_newroutine "${@:2}"
  exit 0
  ;;
fr | find-routine)
  zet_find_routine
  exit 0
  ;;
esac

# Checks if the first given argument is a valid id.
# If it is a zet file, it will open it, otherwise creates a new file
firstArg="$(find "$INBOX" -name "*.${1}.md")"
if [ -n "$firstArg" ]; then
  nvim "$firstArg"
else
  zet_new "$@"
fi
